# Pipeline.py -- Properly defines pipeline file definitions and their interface with
# luigi

import os.path
import luigi
import defutils
import datetime

# This is fundamentally just a container class for luigi module generation.
class Stage:
	isDirectModule=0
	directModuleName=""
	commands=[]
	dependencies=[]
	arguments=[]
	output=[]
	name=""

	# Returns the number of non-macro arguments that can be passed.
	def numArgs(self):
		i=0
		for a in self.arguments:
			toks=a.split(' ')
			if len(toks)>1:
				if toks[1]!="DATE":
					i+=1

		return i

	# Users are allowed to define an argument. 
	def __genArgDef(self, f, argLine, prefix="\t"):
		f.write(prefix)

		# Parse the argument line:
		argLine=argLine.replace('\t', ' ')
		toks=argLine.split(' ')
		
		varname=""
		vartype=""
		default=""
		if len(toks)>0:
			varname=toks[0]
		else:
			return
		if len(toks)>1:
			vartype=toks[1]
		else:
			print("Warning: argument type not specified. Assuming INT.")
			vartype="INT"
		if len(toks)>2:
			default=toks[2]

		f.write(varname+"=")

		if vartype=="INT":
			f.write("luigi.IntParameter(")
		elif vartype=="DATE":
			f.write("luigi.DateParameter(")
		else:
			f.write("luigi.Parameter(")
		
		f.write(default+")\n")

	# Generates a token list that can be used by defutils.
	def getToks(self):		
		tokList=[]

		tokList.append(["name", self.name])
		tokList.append(["type", "stage"])
		tokList.append(["dependencies"])
		tokList[len(tokList)-1].extend(self.dependencies)

		tokList.append(["arguments"])
		tokList[len(tokList)-1].extend(self.arguments)

		tokList.append(["commands"])
		tokList[len(tokList)-1].extend(self.commands)

		tokList.append(["outputs"])
		tokList[len(tokList)-1].extend(self.output)

		return tokList

	def writeFile(self, filename):
		defutils.write(self.getToks(), filename)

	# Compiles a Luigi module with the specified filename.
	def genLuigi(self, filename):
		f=open(filename, "w")
		f.write("# File generated by ariadne on "+str(datetime.datetime.now())+"\n")
		f.write("import luigi\n")
		f.write("class "+self.name+"(luigi.Task):\n")

		# Start with arguments:
		for a in self.arguments:
			self.__genArgDef(f, a)
		
		f.write("\tdef requires(self):\n")
		f.write("\t\treturn ")
		for d in self.dependencies:
			# <Insert file generation and checking magic here>
			# At the moment, d will be written in verbatim.
			if d!=self.dependencies[0]:
				f.write(",")
			f.write(d)
		f.write("\n")

		f.write("\tdef output(self):\n")
		
		for o in self.output:
			# <Insert more or less the same magic as before>
			# We're supposed to define output files or other tasks here.
			f.write("\t\t"+o+"\n")

		f.write("\t\treturn\n")
		
		f.write("\tdef run(self):\n")
		
		for c in self.commands:
			# TODO: Insert command substitution magic here.
			# At the moment, we're just going to go for a passthrough:
			f.write("\t\t"+c+"\n")

		f.write("\t\treturn\n")

		f.close()

	def __init__(self, filename=""):
		if filename=="":
			return

		toks=defutils.parse(filename)
		
		fileType=defutils.search(toks, "type")
		if len(fileType)>1:
			if fileType[1]=="rawstage":
				self.isDirectModule=1
				return
			if fileType[1]!="stage":
				raise defutils.InvalidTypeException()

		# Check if various parsed objects exist:
		tmp=defutils.search(toks, "commands")
		if tmp!=[]:
			self.commands=tmp[1:]

		tmp=defutils.search(toks, "dependencies")
		if tmp!=[]:
			self.dependencies=tmp[1:]
		
		tmp=defutils.search(toks, "arguments")
		if tmp!=[]:
			self.arguments=tmp[1:]

		tmp=defutils.search(toks, "outputs")
		if tmp!=[]:
			self.output=tmp[1:]

		tmp=defutils.search(toks, "name")
		if tmp!=[]:
			self.name=tmp[1]

class Pipeline:
	stages=[]
	stageNames=[]
	topStage=None

	def getToks(self):
		datList=[]
		
		datList.append(["name", self.name])
		datList.append(["type", "pipeline"])
		datList.append(["stages"])
		datList[len(datList)-1].extend(self.stageNames)
		datList.append(["topStage", self.topStage.name])
		return datList

	def writeFile(self, filename):
		defutils.write(self.getToks(), filename)

	def __splitArg(self, arg):
		return arg.split(' ')

	def __useArg(self, argToks):
		return arg[1].upper()=="DATE"

	# Generates a command string for execution:
	# Currently epxects to see args in the same order they were defined. 
	# This includes blank argumen
	def __genArgCommand(self, args):
		execCmd="python -m luigi --module "+self.topStage.name+".py "+self.topStage.name

		i=0
		for a in self.topStage.arguments:
			argToks=self.__splitArg(a)
			if len(argToks)>1:
				if argToks[1]!="DATE":
					execCmd+=" --"+argToks[0]+" "+args[i]
					i+=1

		execCmd+=" --local-scheduler"
		return execCmd

	# Starts executing the pipeline.
	def executePipe(self, args, redirect=0, redirectfile="out.log"):
		cmd=self.__genArgCommand(args)
		
		if redirect:
			p=os.popen(cmd, 'r')
			contents=p.read()
			p.close()
			f=open(redirectfile, "w")
			f.write(contents)
			f.close()
		else:
			os.system(cmd)

	def __init__(self, filename=""):
		if filename=="":
			return

		# Parse the file for all valid attributes:
		toks=defutils.parse(filename)
		
		fileType=defutils.search(toks, "type")
		if len(fileType)>1:
			if fileType[1]!="pipeline":
				raise defutils.InvalidTypeException()

		stageNames=defutils.search(toks, "stages")
		for i in range(1, len(stageNames)-1, 1):
			self.stages.append(Stage(stageNames[i]+".def"))

		# Now generate all stages:
		for s in self.stages:
			if not s.isDirectModule:
				s.genLuigi(s.name+".py")

		topStageInfo=defutils.search(toks, "topstage")
		if len(topStageInfo)<2:
			raise defutils.DefFormatException("No final stage specified in file: "+filename)

		self.topStage=Stage(topStageInfo[1]+".def")
		self.topStage.genLuigi(topStage.name+".py")
		
