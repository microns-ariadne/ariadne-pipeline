#!/usr/bin/env python
# shell2pipe.py -- A quick 'n dirty utility to convert simple shell scripts
#                  to ariadne pipelines.

import os
import sys
import datetime


def printusage():
    """Prints a usage statement."""
    print("Usage: shell2pipe <script.sh> <output_dir> <pipe_name>")


def getname(dir_name, plugin_name):
    """Returns the full name of a generated plugin."""
    return dir_name+"/"+plugin_name+".py"


def getgenstr():
    """Returns a generation stamp string."""
    return "generated by shell2pipe on %s at " % str(datetime.datetime.today())


def genwrapper(f, name, lines):
    """Generates wrapper plugin for the given shell script block."""
    f.write("# %s\n" % getgenstr())
    f.write("import os\nimport plugin\n\n")
    f.write("plugin_class='%s'\n\n\n" % name)
    f.write("class %s(plugin.AriadneOp):\n" % name)
    f.write("    name='%s'\n\n\n" % name)
    f.write("    def run(self, args):\n")
    # Allow users to specify multiple lines:
    for l in lines:
        f.write("        os.system('%s')\n" % l)


def sanitize_evar(envv):
    """Checks an environment variable definition and ensures that it is compatible
       with ariadne's pipeline module.
    """
    toks=envv.split('=')
    pathappend=toks[1].split(':')
    print(pathappend)
    if len(pathappend)>1:
        print("yarr"+toks[0]+'='+pathappend[1])
        return toks[0]+'='+pathappend[1]
    else:
        return envv


def writepdef(f, plist, elist, dname):
    """Writes a pipeline defininition file."""
    f.write("description:\n")
    f.write("   %s\n" % getgenstr())
    f.write("end\n\n")

    f.write("stages:\n")
    for p in plist:
        f.write("   %s:\n" % p)
        f.write("       plugin: %s\n" % p)
        f.write("       runtype: run\n")
        f.write("   end\n\n")
    f.write("end\n\n")

    f.write("environment:\n")
    for e in elist:
        f.write("   %s\n" % sanitize_evar(e))
    f.write("end\n\n")

    f.write("plugindir:\n")
    f.write("   %s\n" % dname)
    f.write("end\n")


def genplist(f, plist):
    """Generates a list of plugins."""
    for p in plist:
        f.write("AriadneOp %s\n" % p)


def convert(script_name, dir_name, pipedef_name):
    """Opens and converts the specified script to an ariadne pipeline."""
    f=open(script_name, "r")
    contents=f.read()
    f.close()
    lines=contents.splitlines()

    # Make sure that the directory exists:
    if not os.path.isdir(dir_name):
        os.mkdir(dir_name)

    next_plugin_name=""
    plugin_list=[]
    env_list=[]

    pdeff=open(pipedef_name+".pipeline", "w")

    cmd_buf=[]

    for l in lines:
        if len(l)>0:
            ltoks=l.split()
            if l[0]=='#' and l[0:2] != '#!':
                # Write out the previous command list:
                if len(cmd_buf)!=0:
                    f=open(getname(dir_name, next_plugin_name), "w")
                    genwrapper(f, next_plugin_name, cmd_buf)
                    f.close()
                    cmd_buf=[]
                next_plugin_name=l[1:].strip()
                plugin_list.append(next_plugin_name)
            elif ltoks[0]=="export":
                env_list.append(ltoks[1])
            elif l[0:2] == '#!':
                pass
            else:
                cmd_buf.append(l)

    # Ensure that the last plugin is covered:
    if len(cmd_buf)!=0:
        f=open(getname(dir_name, next_plugin_name), "w")
        genwrapper(f, next_plugin_name, cmd_buf)
        f.close()
        cmd_buf=[]

    writepdef(pdeff, plugin_list, env_list, dir_name)
    pdeff.close()
    f=open(dir_name+"/plugins.list", "w")
    genplist(f, plugin_list)
    f.close()
    

def main(args):
    if len(args)<4:
        printusage()
        return

    convert(args[1], args[2], args[3])


if __name__=="__main__":
    main(sys.argv)
